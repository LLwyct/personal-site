{"componentChunkName":"component---src-templates-article-detail-js","path":"/articles/类的创建和继承以及在ES5/6中的区别","result":{"data":{"markdownRemark":{"html":"<ul>\n<li><a href=\"#1-%E7%BB%A7%E6%89%BF\">1 继承</a>\n<ul>\n<li><a href=\"#11-%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF\">1.1 原型链继承</a></li>\n<li><a href=\"#12-%E6%9E%84%E9%80%A0%E7%BB%A7%E6%89%BF\">1.2 构造继承</a></li>\n<li><a href=\"#13-%E5%AE%9E%E4%BE%8B%E7%BB%A7%E6%89%BF%E6%8B%B7%E8%B4%9D%E7%BB%A7%E6%89%BF\">1.3 实例继承、拷贝继承</a></li>\n<li><a href=\"#14-%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF\">1.4 组合继承</a></li>\n<li><a href=\"#15-%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF\">1.5 寄生组合继承</a></li>\n</ul>\n</li>\n<li><a href=\"#2-instanceof\">2 instanceof</a></li>\n<li><a href=\"#3-isprototypeof\">3 isPrototypeOf</a></li>\n<li><a href=\"#4-es5-es6%E4%B8%AD%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8C%BA%E5%88%AB\">4 ES5 ES6中继承的区别</a></li>\n</ul>\n<h1>1 继承</h1>\n<h2>1.1 原型链继承</h2>\n<p>说一下原型链继承把，这个方法其实让我纠结了好久，因为它与我在一篇官方的文章里讲的不一样。先直接看代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Animal</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name <span class=\"token operator\">||</span> <span class=\"token string\">\"Animal\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function-variable function\">sleep</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token function\">sleep</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"sleeping\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">Animal</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">eat</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">food</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">+</span> <span class=\"token string\">' eating '</span> <span class=\"token operator\">+</span> food<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// 上面的部分是通用代码</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">Cat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">Cat</span><span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Animal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> cat <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Cat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mimi\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ncat<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"mimi\"</span><span class=\"token punctuation\">;</span>\ncat<span class=\"token punctuation\">.</span><span class=\"token function\">eat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fish\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这是一段比较经典的原型链继承方法但是要注意，如果倒数第二行不主动再次声明<code class=\"language-text\">name</code>为mimi的话，会打印Animal eating fish，也就是说构造函数中的参数<code class=\"language-text\">name=mimi</code>，是没有用的。</p>\n<p>在一篇比较权威的js教程中提到，尽量不要去覆盖函数的<code class=\"language-text\">prototype</code>属性，而是在其上做插入。比如上述代码第七行那样。如果直接覆盖会失去其原型中的<code class=\"language-text\">constructor</code>属性，因为即使是一个空函数，它也有它的 <code class=\"language-text\">prototype</code> 属性，而这个空函数的 <code class=\"language-text\">prototype</code> 就是一个只包含 <code class=\"language-text\">constructor</code> 的对象，这个 <code class=\"language-text\">constructor</code> 就是这个函数本身，即 <code class=\"language-text\">F.prototype.constructor === F</code> 返回真。</p>\n<p>但是这里的原型链继承中，使用了这种覆盖的方法。经测试，<code class=\"language-text\">Cat.prototype.constructor === Animal</code>。这就比较能看出来问题了。我个人理解是，<code class=\"language-text\">F</code>的<code class=\"language-text\">prototype</code>是<code class=\"language-text\">animal</code>对象，而其上是没有<code class=\"language-text\">constructor</code>的，所以去<code class=\"language-text\">animal</code>的原型上找，而animal的原型上的<code class=\"language-text\">constructor</code>就是<code class=\"language-text\">Animal</code>函数。所以我还是比较不太喜欢这种方法的。</p>\n<p>而且这种方法有一个致命的缺点，就是如果父类的属性是引用类型，由于将父类的实例置给了子类的原型，因此不同的子类实例会使用同一个原型，引用类型会共享，一个改动，其他跟着一起变。</p>\n<h2>1.2 构造继承</h2>\n<blockquote>\n<p>使用父类的构造函数来<strong>增强</strong>子类实例，等同于复制父类的实例给子类（没有用到原型）。</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Cat</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">Animal</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> cat <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Cat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mimi\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ncat<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// > mimi is sleeping</span>\ncat<span class=\"token punctuation\">.</span><span class=\"token function\">eat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fish\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// > Uncaught TypeError: cat.eat is not a function</span></code></pre></div>\n<blockquote>\n<p>特点，可以实现多继承。\n缺点：<strong>只能继承父类实例的属性和方法，不能继承父类原型上的属性和方法</strong>。每个子类都有父类实例函数的副本，影响性能。</p>\n</blockquote>\n<p>核心代码是 <code class=\"language-text\">Animal.call(this)</code>，创建子类实例时调用父类构造函数，于是子类的每个实例都会将SuperType中的属性复制一份。</p>\n<p>我的理解，这种方法实际上没有用到原型，因为这里是用的<code class=\"language-text\">Animal()</code>函数去执行。所以，相当于借用Animal去创建了一个cat实例，而cat对象是没有原型链的。因此 <code class=\"language-text\">cat.__proto__.__proto__ === Object.prototype</code>。否则，应该是 <code class=\"language-text\">cat.__proto__.__proto__ === Animal.prototype</code>。</p>\n<h2>1.3 实例继承、拷贝继承</h2>\n<p>不常用，略</p>\n<h2>1.4 组合继承</h2>\n<blockquote>\n<p>相当于原型链继承和构造继承的组合体。通过调用父类构造函数，继承父类的属性并保留传参的优点，然后将父类实例作为子类原型，实现函数复用。</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Cat</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">Animal</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name <span class=\"token operator\">||</span> <span class=\"token string\">'Tom'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">Cat</span><span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Animal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Cat</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>constructor <span class=\"token operator\">=</span> Cat<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> cat <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Cat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mimi\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ncat<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// mimi is sleeping</span>\ncat<span class=\"token punctuation\">.</span><span class=\"token function\">eat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fish\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// mimi eating fish</span></code></pre></div>\n<p>先说原型链继承，从名字就可以听出来，这种继承方法是有原型链在里面的，因此解决了构造继承中没有原型的问题，然后可以看到与构造继承相比，主动声明了Cat的原型，并且在原型链继承的基础上主动插入了被覆盖的构造函数constructor。</p>\n<p>特点：可以继承实例属性/方法，也可以继承原型属性/方法。</p>\n<p>缺点：</p>\n<ul>\n<li>第一次调用new Animal()：给Animal.prototype写入属性name。</li>\n<li>第二次调用new Cat(\"mimi\")：给cat写入属性name。</li>\n</ul>\n<p>实例对象cat上的属性就屏蔽了其原型对象Cat.prototype的同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。</p>\n<h2>1.5 寄生组合继承</h2>\n<blockquote>\n<p>通过寄生方式，砍掉父类的实例属性，这样在调用两次父类的构造时就不会初始化两次实例方法/属性。</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Cat</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">Animal</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name <span class=\"token operator\">||</span> <span class=\"token string\">'Tom'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token class-name\">Cat</span><span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Animal</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Object.create's polyfill</span>\n<span class=\"token keyword\">let</span> <span class=\"token function-variable function\">Super</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Super</span><span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token class-name\">Animal</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Cat</span><span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//</span>\n\n<span class=\"token class-name\">Cat</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>constructor <span class=\"token operator\">=</span> Cat<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> cat <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Cat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mimi\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ncat<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// mimi is sleeping</span>\ncat<span class=\"token punctuation\">.</span><span class=\"token function\">eat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fish\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// mimi eating fish</span></code></pre></div>\n<p>这是最成熟的方法，也是现在库实现的方法</p>\n<p>可以看到这里用了一个空的函数在中间作为传递者，在组合继承中，子类Cat的原型就会创建一个Animal实例，由于Animal有可能内部有很多东西，那么就会需要很大内存，但其实这里是不需要的，因此这里使用一个空的函数作为中间传递者，这样创建cat实例的时候，就只需要一个空函数对象，节约了内存的。</p>\n<h1>2 instanceof</h1>\n<p>判断class的原型是否在obj的原型链上</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">obj <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">class</span></code></pre></div>\n<h1>3 isPrototypeOf</h1>\n<p>从名字就可以看出来用于判断前者是否是后者的原型链上的原型</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token class-name\">Function</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">isPrototypeOf</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span>\n<span class=\"token class-name\">Child</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">isPrototypeOf</span><span class=\"token punctuation\">(</span>child1<span class=\"token punctuation\">)</span>\n<span class=\"token class-name\">Parent</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">isPrototypeOf</span><span class=\"token punctuation\">(</span>child1<span class=\"token punctuation\">)</span></code></pre></div>\n<h1>4 ES5 ES6中继承的区别</h1>\n<p>ES5的继承是通过先创建子类的实例，再将父类的方法或对象通过父类构造函数添加到子类上。</p>\n<p>在ES6中，语言内部实现了extends功能。子类必须在构造函数中调用父类的super方法来创建实例。</p>\n<p>其背后的原因是因为：\n在 JavaScript 中，继承类（所谓的“派生构造器”，英文为 “derived constructor”）的构造函数与其他函数之间是有区别的。派生构造器具有特殊的内部属性 [[ConstructorKind]]:\"derived\"。这是一个特殊的内部标签。</p>\n<p>该标签会影响它的 new 行为：</p>\n<ul>\n<li>\n<p>当通过 new 执行一个常规函数时，它将创建一个空对象，并将这个空对象赋值给 this。</p>\n</li>\n<li>\n<p>但是当继承的 constructor 执行时，它不会执行此操作。它期望父类的 constructor 来完成这项工作。</p>\n</li>\n</ul>\n<p>因此，派生的 constructor 必须调用 super 才能执行其父类（base）的 constructor，否则 this 指向的那个对象将不会被创建。并且我们会收到一个报错。</p>\n<p>这也从另一方面证实了，class并不是函数+原型的语法糖！</p>\n<p>首要原因是：</p>\n<ul>\n<li>\n<p>class创建的函数具有<strong>特殊内部属性标记</strong> <code class=\"language-text\">[[FunctionKind]]:&quot;classConstructor&quot;</code></p>\n<p>编程语言会在许多地方检查该属性。例如，class方法只能用new调用。</p>\n</li>\n<li>\n<p>class方法不可枚举。类定义将\"prototype\"中的所有方法的enumerable标志设置为false。这很好，因为如果我们对一个对象调用for..in方法，我们通常不希望class方法出现。</p>\n</li>\n<li>\n<p>类总是自动使用 use strict。</p>\n</li>\n</ul>","frontmatter":{"title":"类的创建和继承以及在ES5/6中的区别","label":"JavaScript&继承","date":"2021-05-25 22:02:00","autonav":1},"timeToRead":6}},"pageContext":{"title":"类的创建和继承以及在ES5/6中的区别"}},"staticQueryHashes":[]}